Given the below dataframe, if rows are grouped by first name and last name, how can I find and create new rows for a group that does not have a row for every type in the types list. So in the example below, two new rows would be created for Bob Jack that are missing from the original dataframe: one with type 'DA' and another with type 'FA', the value columns can be set to 0. One way to do this is to create a dataframe which is all the combinations of names and types, then left join that to the original dataframe. This will create a df with all combinations, with NaN values where there was a missing entry in the original data. That can then be filled with 0 . Note that because the value column gets NaN values in it, it is converted to type float. You can convert that back to int if desired using astype({'Value': int}) in the chain: Output (with the astype to convert Value back to int): We can pivot the dataframe to make it wide, which creates the missing types for Bob. Then unpivot the frame to make it back into a long dataframe. We can also use set_index , unstack instead of pivot_table for the same effect. Using janitor 's complete : Output: Since types is the same across all groups, you can get more performance by avoiding the by parameter: If the column contains all the types, you can avoid the dictionary and pass the column name instead: One solution is to loop through all the groups and concatenating rows when any type is missing: Output: