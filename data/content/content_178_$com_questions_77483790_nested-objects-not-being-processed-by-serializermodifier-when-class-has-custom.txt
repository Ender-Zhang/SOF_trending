Okay, so I've built a functional custom BeanSerializer , which limits the depth of serialization, and I can use it as shown by creating a SerializerModifier and adding it to module.  This WORKS great and is called each time another nested field is encountered, creating the instance of DepthLimitedSerializer perfectly.  HOWEVER, when I add a custom serializer to the nested class (using @JsonSerialize ), then my modifySerializer method NEVER RUNS on the nested field! Here is the simple class hierarchy, of which we will serialize the outer instance of Bar : And here is the simplified custom serializer to which you pass a maxDepth and if it reaches that depth, it ONLY serializes a single ( id ) field, otherwise, it simply calls the super : In this simple test we populate a Foo and a Bar and serialize them: This gives us exactly what we expect, notice that with a depth of 0 , we only get the id field of the nested Foo fooOfBar , which is correct, but at a depth of 1 , we get the full output.  This works to arbitrary depths just fine, and when it runs, that modifySerializer method as well as those in the DepthLimitedSerializer all run for EACH nested model! HOWEVER!  If one of these subclasses of BaseClass requires custom serialization, and I attempt to add a custom serializer for a particular class, like Foo : And I uncomment the above @JsonSerialize(using = FooSerializer.class) line and assign the custom serializer to the class, then my modifySerializer method and all others are NEVER RUN for my custom-annotated nested class, and so the depth is ignored and the custom serializer just ALWAYS runs: The behavior I would have expected is for the modifySerializer method to STILL be run, and then for the super.modifySerializer() call to find that the FooSerializer , but instead it's only run for the top-level object (and others, not so custom annotated). How can I achieve this behavior?  I tried to make the custom serializer extends DepthLimitedSerializer , but they are of different types of Jackson Serializer` and I have thus far been unable to reconcile them and get them to work together in the correct order!  Clearly I can't use the annotation to assign the serializer, but how can I? Thank you all. Here is my final working solution.  I almost think it's a bug that serializers which were assigned via annotation are NOT processed by SerializerModifiers attached to the ObjectMapper .  Nothing in the documentation says they'll "modify serializers, but oh, not those serializers."  My solution is a bit hacky, but it works. First, a custom BeanSerializerFactory to add running the modifiers if the serializer is found via annotation.  This happens right at the beginning of the overridden method anyway. Now, this DepthLimitedSerializer is a LOT longer than it needs to be, mostly because I had to duplicate a lot of the code from BeanSerailzier .  Why, you ask?  Because the serialize method in BeanSerializer is final, so I can't override it.  Instead, I'm forced to override BeanSerializerBase and copy a bunch of code from it. This annotation marks the classes included and lets us pass a few arguments. And here is our POJO hierarchy to demonstrate: A custom serializer for Foo : And finally, the demonstration: And here in the final output you can see that the custom serializer runs when the depth is set to 1 , but doesn't run (null is used) when the depth is set to 0 , exactly as it should.