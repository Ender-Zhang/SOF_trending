I have some problems using the Process and ProcessBuilder classes in Java. Here's my existing code, which works (this is code being executed in a JUnit test btw): The readAllAsString() method looks like this: This works fine, but it doesn't handle all scenarios. What if the process doesn't exit normally, but sits and wait for input on its standard input? So, I'm trying to add something like this: ...but this is where the problem starts. The test sits and waits forever; it never reaches the end of the InputStream . The readAllAsString() method probably reaches the end of the stream and then blocks, waiting on the process to write any more data to it. (Note: this is just my assumption, I haven't verified this in the debugger) If I try to workaround this by adding a destroy() call like this: ...I get an exception when trying to read the data from the stream: How can I workaround this? What's the proper way to read all the data from this InputStream , without blocking at the end of the available data? Or are there any other, better ways to fix this? The problem with using CharStreams.toString() for this is that it expects the stream to have reached EOF. In cases where the process is still running, this is not the case. If you rewrite the readAllAsString() method like this it works, with a few caveats: All input must be currently available. This method is non-blocking; it just reads the data from the InputStream which is currently available. Any output written by the process after the readAllAsString() method is called will not be included. This presumes that the buffer for the pipe doesn't get full. On my current Linux system the limit seems to be 1 MiB ( cat /proc/sys/fs/pipe-max-size ).