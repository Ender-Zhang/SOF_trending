Background I have an interface And an implementation The Problem The Set returned by getAllThings() will reflect any changes made within my registry However, the Set returned by getAllThingsWithProperty() will not reflect these changes The Question Is there any way using standard java libraries, or some incredibly common third party library, to make the return value of getAllThingsWithProperty() to be a "live" sub Set ? I.E. it "backed by" the original Set but reapplies the Predicate each time its accessed? Preferably something that could apply to any Collection as I have another Registry interface which uses a List . I know I could write my own Set implementation but would prefer to avoid that. Instead of a method that returns a Set<Thing> . You can write a method that returns a Supplier<Set<Thing>> . And each time you want to get the current Set , you call that Supplier 's get() method. It's fairly straightforward to use AbstractSet to bring up a Set implementation. All you need to do is to implement the size and iterator methods. You're using streams already, so you can just use streams to implement these methods: This is a fully functional, read-only Set . It provides a "live view" of the backing set, since its elements are streamed and filtered on every operation. This is workable for sets with small numbers of elements, but it can slow down noticeably as the number of elements grows. For example, the contains method potentially iterates the entire set and is thus O(N). You could override the contains method to delegate directly to the backing set. This will reduce the time complexity to whatever the underlying set provides -- for HashSet , this is O(1) -- but there are some subtleties involved. To make the set read-write, you'd need to implement the add method and reimplement the iterator so that it supports the remove method. But you were returning unmodifiable sets in the first place, so maybe you don't need that. If you need to do something similar with List , take a look at AbstractList . It's fairly straightforward. Or use AbstractCollection to wrap any collection the same way as shown here with AbstractSet .