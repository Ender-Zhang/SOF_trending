I'd like to recursively find all .md files of the current directory that contain the “Narrow No-Break Space” U+202F Unicode character between the two strings \begin{document} and \end{document} , possibly (and in fact essentially) not on the same line as U+202F . A great addition would be to replace such U+202F s by normal spaces. I already find a way to extract text between \begin{document} and \end{document} with a Python regexp (which I used to find easier for multi-line substitutions. I tried to use it just to list files with this pattern (planning to afterwards chain with grep to at least get the files where this pattern contains U+202F ) but my attempts with: but I got unintelligible (for me) errors: Assuming you are correctly reading or decoding an encoded file... I would do something along these lines. Given your example on regex101 (which I modified as seen): The result is: (The non-breaking spaces are replaced with ! for clarity...) From the comment running python test.py doesn't change test.md : CAREFUL!!! This code will recursively change every .md file in a tree (it does make backups as updated.) You can achieve this by splitting and joining your string. A Javascript code for it looks like this: You can implement something similar in the language of your choice. When that's reliable, just implement something that loops your files and calls this for its content. If the content changes, save. The error message means you did not quote the regex correctly. This is a bit of a design wart in Python; the backslash has one meaning in quoted strings, and another in regular expressions, which however need to be passed inside quoted strings. The usual remedy these days is to use the r"..." "raw string" in Python for regular expressions; it simply makes the backslash a normal character as far as Python is concerned, inside this string, and so you don't need to wrap everything in a second layer of escaping backslashes. An equivalent but murkier solution would be to double all the backslashes. In a future version of Python, you will even get a syntax error if you try to use invalid escapes like \s or \z in a regular string. In some more detail, Python reserves sequences like \t and \n for representing tab and newline, respectively (there's a handful more, and of course \\ to denote a literal backslash), and any other use of a lone backslash followed by a character is semantically murky, and will be turned into an error. (The legacy behavior was simply to ignore the backslash.) Inside a regular expression, you want sequences like \s or \d or \[ or \. (and many more) which have special meaning to the regex engine, but these have to be represented as \\s or \\d or \\[ or \\. , respectively, in a regular Python string, so that what the regular expression parser sees, once Python has parsed the string into its internal representation, is a regular backslash followed by another character. The below code removes the target character found only between \begin{document} and \end{document} in " basename .md" files, and writes the new content to " basename .md.new".  I used a visible character (U+2014 EM DASH) to make it more obvious. Note that the encoding of the .md files must be known and consistent .  UTF-8 encoding is common on *nix, but not Windows.  It is a good practice to be explicit about the encoding since the default varies by OS. Also note that re.DOTALL is needed for . to match newlines.  Default is to match all character except newlines. test.md test.md.new