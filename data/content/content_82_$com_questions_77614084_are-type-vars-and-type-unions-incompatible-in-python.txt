Consider the following snippet: I have created a TypeVar to hint that f expects as input a float or an array and will return an output of the same type. The type hint in g is more loose. It expects either a float or an array and will return a float or an array, without constraining the type of the output to the type of the input. Intuitively, the setup makes sense. Inside the definition of the g function we know that we expect x to be either a float or an array, i.e. what f expects as input. However when I pass x to f at the last line, Pyright complains: Argument of type "float | ndarray[Unknown, Unknown]" cannot be assigned to parameter "x" of type "T@f" in function "f" Type "float | ndarray[Unknown, Unknown]" is incompatible with constrained type variable "T" This is surprising and frustrating, because it means that one cannot use my function f without being very cautious about the way they write their type hints. Any thoughts on how to solve this? Edit :
After the comment of Brian61354270, I have recreated essentially the same example, only with no dependence of numpy. Here instead of numpy array we use Fraction : Again, Pyright reports essentially the same issue: Argument of type "float | Fraction" cannot be assigned to parameter "x" of type "T@f" in function "f" Type "float | Fraction" is incompatible with constrained type variable "T" Interestingly, if instead of Fraction we use int , the type check passes: Are type vars and type unions incompatible in python? This isn't the issue. The type variable defined, T = TypeVar("T", float, Fraction) , is constrained to float or Fraction . f(x: T) can only accept an instance of float or Fraction , not the union float | Fraction . Your example can be reduced to the following ( Pyright Playground , mypy Playground ) I don't exactly know what your f and g needs, but If you still require type constraints (e.g. if all the inferred return type of f should be upcasted to exactly one of float , Fraction , or float | Fraction ), you'll need to add the union as an additional constraint: If you don't require type constraints, then setting an upper bound is easier: While not a desirable solution, you can resolve this error by repeating the call to f in g under explicit type guards: Output using pyright v1.1.329: