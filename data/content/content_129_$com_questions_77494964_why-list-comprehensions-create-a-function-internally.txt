This is disassembly of a list comprehension in python 3.10: From what I understand it creates a code object called listcomp which does the actual iteration and return the result list, and immediately call it.
I can't figure out the need to create a separate function to execute this job. Is this kind of an optimization trick? The main logic of creating a function is to isolate the comprehension’s iteration variable peps.python.org . By creating a function: Comprehension iteration variables remain isolated and don’t overwrite
a variable of the same name in the outer scope, nor are they visible
after the comprehension However, this is inefficient at runtime . Due to this reason, python-3.12 implemented an optimization called comprehension inlining(PEP 709) peps.python.org which will no longer create a separate code object peps.python.org . Dictionary, list, and set comprehensions are now inlined, rather than
creating a new single-use function object for each execution of the
comprehension. This speeds up execution of a comprehension by up to
two times . See PEP 709 for further details. Here is the output for the same code disassembled with python-3.12 : As you can see, there is no longer a MAKE_FUNCTION opcode. Instead python-3.12 uses LOAD_FAST_AND_CLEAR docs.python.org (at offset 6 ) and STORE_FAST (at offset 30 ) opcodes to provide the isolation for the iteration variable. Quoting from the Specification section peps.python.org of the PEP 709: Isolation of the x iteration variable is achieved by the combination
of the new LOAD_FAST_AND_CLEAR opcode at offset 6 , which saves any
outer value of x on the stack before running the comprehension, and 30 STORE_FAST , which restores the outer value of x (if any) after running
the comprehension. And here is the benchmark results peps.python.org (measured with MacOS M2): List comprehensions in Python don't create a function internally. They are a concise way to create lists. If you're referring to lambda functions, they can be used within a list comprehension to apply a function to each element. However, list comprehensions themselves are not functions; they're a syntactic construct for creating lists. list comprehensions in Python do not create a function internally. List comprehensions are a syntactic construct for creating lists in a concise and readable manner. They are not equivalent to creating or using functions, and they do not involve the creation of functions behind the scenes. List comprehensions are more closely related to loops, as they provide a compact way to express a loop that constructs a list. They are a shorthand notation for creating lists and are evaluated in a single line. Here's an example to illustrate: original_list = [1, 2, 3, 4, 5]
new_list = []
for item in original_list:
new_list.append(item * 2) Equivalent list comprehension new_list_comprehension = [item * 2 for item in original_list] print(new_list)  # Output: [2, 4, 6, 8, 10]
print(new_list_comprehension)  # Output: [2, 4, 6, 8, 10] In the example above, the list comprehension [item * 2 for item in original_list] is a concise way to achieve the same result as the for loop without explicitly creating a separate function. To reiterate, list comprehensions are not functions; they are a specific syntax for creating lists. Functions, on the other hand, are defined using the def keyword and involve a more general mechanism for encapsulating reusable blocks of code.