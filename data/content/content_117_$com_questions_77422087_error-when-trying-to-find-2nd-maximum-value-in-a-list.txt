I am trying to write code for finding the second maximum value of a list. I tried it like this: And the second maximum value and the maximum value comes out to be the same. What is the mistake in my program? The issue TLDR Should be How to find the Issue 1. Make the code simpler Comprehension instead of map - list constructor succession We can reduce the boilerplate of firsts lines by using a comprehension instead of a succession of map and list constructors: become: Ask the max to Python, don't do it yourself The next block of your logic is here to find the max of the list.
You don't need to write this code yourself, you can ask Python. This will reduce the complexity of your code, making the issue/bug easier to spot. become: Rename variables To help our brain understand what happens, let's clarify variables names: become: 2. Find the issue Now, the code is smaller, easier to understand, with less place for error. If there is an error, we don't have to look at many places. What's wrong? second_max should be the 2nd maximum value, but it's not.
What could cause that? An update of previous_value that shouldn't happen. So this is where the issue might happen. The attribution is correct, the condition should be wrong. This seems correct second_max < current_value since we want to update only if second_max is lower than current_value (meaning that current might be the true second_max value OR equal to max_value .
So we need another condition: current_value shouldn't be the max_value , otherwise, second_max might be set to the max_value . And, we look at the second condition: second_max < max_value . Here is our mistake. Let's fix the condition, since it's current_value that should be lower than max_value .
Also, the initial value of second_max need to be set at the minimum value in case the first value is the max. Done. Alternative: Use set, sorted and index If you want the second maximum value in a list, it is easier to sort a de-duplicated list and print the element at index 1 of the list e.g. the second element. Step by Step Example Oneliner Example With heapq The test in your second loop is incorrect, use this: The checked value ( j ) should not be equal to the max_value . Interestingly, your method (with the logic correction) is very fast compared with other common ways of doing this. It is f1 in the benchmark below. Here is an online BENCHMARK . And the code if you want to try on your own computer: On a recent Mac, this prints: I would write the code like this: The code is more testable with the function split out. The caller similar to the poster's code would look like: The code raises an IndexError exception if there is a single unique value or no values in the list passed in. Here is simple test data I tested with: 2023-11-14 You can write the code like this for the benchmarking code below: or like this for datasets with few duplicates: The second implementation is the fastest alternative so far, according to the benchmarking code, running 66% faster than f8.  The answers couldn't solve the exception where the list starts with the max value. To solve it, In second for , j!=max_value and j<max_value both work.