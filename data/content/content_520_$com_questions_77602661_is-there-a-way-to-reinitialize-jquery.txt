The bounty expires in 3 days . Answers to this question are eligible for a +500 reputation bounty. Daniel Kaplan is looking for an answer from a reputable source : IMHO, say this is useful knowledge if you use JSDOM to test code that uses jquery. Question JQuery is initialized on import . If window and window.document exist (and module doesn't), JQuery saves the references and uses them thereafter. Is there a way I can "reinitialize" or "reset" JQuery after it's been import ed to give it a different reference to window and document ? A failing testcase Project Structure ./index.spec.js ./template1.html ./template2.html This is an excerpt of the code, but you can find a complete github repository here. Context I'm working on a frontend-only, single page app project. Even though the project runs exclusively in the browser, the automated tests run in Node.JS. The tests load the html in JSDOM and execute portions of the production code. 1 On creation, JSDOM returns a DOM API that works in Node.JS, including a window object. Without this, jQuery will error on import because modern versions have code like this : As you can see, this executes as a side effect of import ing jQuery. This has caused considerable headache because it isn't always straightforward to create JSDOM before importing jQuery. For example, if the production code imports jQuery and the test imports the production code, JSDOM (and therefore window ) won't exist yet. This throws an error. But here's a more important use case: I want to be able to use different HTML files in my tests, but this is limiting me to one per test run. Notes For the record, I'm using jQuery 3.7.1, but stackoverflow code snippets don't give me the option to pick that version. I think that's fine because, as far as I can tell, this code is the same in both. 1 : Unfortunately, that means going against the official JSDOM advice. But in this context, I can't see a way around that. Everything is in your code already: This means that if there is no window with a document available on the global scope, the import will provide the factory it uses instead of executing it with the available window object and returning the instantiated jQuery. If you change your parseHTML code to leverage this: If you do not make the window object available in the global scope, you'll receive the jQuery factory. You'll then be able to instantiate it the way you need, by passing the window object that you care about. More details on why your solution was not working When you import code/modules, the parsing and execution of the imported file is only done once (on the first import) and the resulting value is kept inside a cache so later imports do not need to work as much, but this causes your import value to always be the same. The note clearly reads: JSDOM gives you access to the window , pass the window to the jQuery factory to create a jQuery Object attached to that window. Here is a minimal example: Usage: