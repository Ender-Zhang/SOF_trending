This question already has answers here : Behavior of __new__ in a metaclass (also in context of inheritance) (2 answers) Closed 16 days ago . Why does it print <class 'type'> , but not <class '__main__.Meta'> Am I right that class WithAttr is instance of Meta? This is because you're making an explicit call to type(name, bases, dct) , which in turn calls type.__new__(type, name, bases, dct) , with the type class passed as the first argument to the type.__new__ method, effectively constructing an instance of type rather than Meta . You can instead call type.__new__(cls, name, bases, dct) , passing the child class as an argument to contruct a Meta instance. In case __new__ is overridden in a parent class that is a child class of type , call super().__new__ instead of type.__new__ to allow the method resolution order to be followed. Change: to: Demo: https://ideone.com/KIy2qG This is due to the metaclass assignment and how Python handles metaclasses. If, within Meta.__new__ , we create the instance using super().__new__ , the metaclass Meta will properly used to create the class WithAttr : This works by ensuring that the object returned from __new__ is a Meta instance.