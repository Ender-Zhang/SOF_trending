Here's the code I'm working with right now: Expectation ( setTimeout starts counting down right away) The first setTimeout will execute and start the timer for 2000 ms. However, since setTimeout callbacks are ran asynchronously, we'll have to skip over it and wait for the full call stack to finish before going through the callback queue. Go through the for loop. From my computer, it took around ~20 seconds for the whole for loop to finish running. Around a few seconds into the for loop, the first setTimeout should be done with it's timer now. The second setTimeout will then execute and start the timer. Similar to the first step Now that the call stack is done running, we go through the callback queue. Since the first setTimeout should've finished the delay first despite the higher delay, it should print "first" then "second" Actual Seems to be the case that the second setTimeout still runs first. In this case, does this mean that the setTimeout countdowns only begin after the initial few lines of code are ran? I've tested this code on both Firefox and Chrome, and they seem to have the same behavior. Your expectation is correct, but the provided sample is deceptive. The for-loop does not take ~20 seconds. JavaScript finishes way sooner. It might take the JavaScript container (like your Browser) around 20 seconds to print everything, but the script just continues on. setTimeout(() => console.log('second'), 1*SECOND) is executed less than a second after setTimeout(() => console.log('first'), 2*SECONDS) . You can see how long the loop actually takes by comparing the start and end time of the loop. Here is an example of some code that is actually busy for about 5 seconds.