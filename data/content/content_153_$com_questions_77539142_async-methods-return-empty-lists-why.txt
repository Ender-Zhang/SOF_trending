I'm trying to play around with @Async . My first experience with it isn't very positive. I get an empty list where results are definitely expected MRE: The method doesn't return anything: Why is it happening? While I don't know the exact cause, it seems to be related to how transactions are handled in @DataJpaTest . If you run the application regularly, the findAll() method works fine. Similarly, if you use @SpringBootTest in stead of @DataJpaTest , your test also works: The reason why I suspect that this is transaction related is because if I change the execution phase of the SQL to be BEFORE_TEST_CLASS , your test succeeds: Alternatively, if I annotate your test with @Transactional(propagation = Propagation.NEVER) , your test also succeeds: The cause of the test failure is due to a combination of: The @DataJpaTest annotation itself is annotated with @Transactional , this mean the test will run inside a transaction, also indicated by the Javadoc in DataJpaTest : By default, tests annotated with @DataJpaTest are transactional and roll back at the end of each test. Your test is using @Sql(executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD, ...) , so the SQL scripts will run within the test's transaction, therefore any data created by the script is uncommitted data while the test is running. Your async findAll() will run in a different thread, outside of the test's transaction, and due to transaction isolation (default is read committed), it will not see uncommitted data created in the test, hence it will return nothing. Any one of the following can workaround this (mostly copied from the answer by @g00glen00b) and why they work: Use @SpringBootTest instead of @DataJpaTest - this works because @SpringBootTest itself is not annotated with @Transactional , so there is no outer transaction wrapping the test, everything is committed as soon as their calls finish, so findAll() will see the committed test data. Use @Transactional(propagation = Propagation.NEVER) or Propagation.NOT_SUPPORTED on the test, this essentially suspends the test transaction coming from @DataJpaTest , so will cause the test to run without a wrapping transaction, having similar affect as the above. Use @Sql(executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS, ...) - this runs and commits the test data before the test starts, therefore not affected by the test's own transaction. Remove @Async on findAll() - this will cause findAll() to run within the same transaction, therefore will see uncommitted data. When you use @Async on a method, Spring creates a proxy around that method to handle the asynchronous behavior. However, if the method is called from within the same class, the proxy won't be invoked, and the asynchronous behavior may not take effect. There are couple of thing that can be tried to get rid of the issue - Move the findAll() call to another class:
Create a separate service or component class, inject the AsynchronousCardRepository into that class, and call the findAll() method from there. This ensures that the proxy is invoked, and the asynchronous behavior is properly handled. In Test Class
@Autowired
private CardService cardService; Use CompletableFuture instead of Future:
You can modify the return type of the findAll() method to use CompletableFuture directly. This might work more seamlessly with Spring's asynchronous processing. Let me know if this resolves your problem.