For example, I have an array : [1,1,2,2,2,3,4,4,4], I want a result that group the same adjacent objects into another array : [[1,1],[2,2,2],[3],[4,4,4]], how can I do that? I tried: Which I expect [[1,1],[2,2,2],[3],[4,4,4,4]] but I don't know why would it be [[1,1],[2,2,2],[3]] (missed the last group). I also tried but the result is [[1,1],[2,2,2],[3],[4,4]], which missed a "4" at the last group. How do I fix it? You are not dealing with the last group. Your idea is obviously to push the last group (made of everything from i, included to j, excluded) when you find an element that is different from the previous. But the last group has no follower different from the previous. There are ways to solve that. For example Based on the fact that || is a lazy or. So if j is arr.length then arr[j-1]!=arr[j] would not be evaluated. Which avoids using an index out of bound. Even tho, in javascript, it would not be a big deal: arr[j] would then just be undefined , which is ok for us, unless arr[j-1] also is, that is unless undefined is a possible value of arr content. You could also simply, after the loop, add every thing after the last i (but for that you need i to exist outside the loop, so the let i=0 be done before the loop). I don't spend to much time on that, I am sure that you'll have answer for many ways to do the task.
What  I mainly want to point out, is another possibility, taken from "The Art of Computer Programming" , and often overlook: a sentinel . Since your problem is the particular case of last group having no successor, just add a successor. Sure, that means altering arr . So it is not always feasible. But then it avoid the cost of testing j==arr.length at every iteration. Again, that is also avoidable by treating that special case after the group. So, I am not claiming sentinel is the only option, nor that it is the faster one. Just, that it worth to be known. As you can see, to the cost of just one line (adding the sentinel) I can keep your code as is. Note that the simpler solution (the one given in comments by Marc), that is just letting j go to arr.length included, is implicitly a version of that: arrays in javascript have implicit undefined after all their elements. So, if, as my whateveraslongasitisnot4 , undefined is not to be found in array, and especially not at the end, then, that implicit undefined acts as a sentinel. Not sure it was thought that way, but that is a way of seeing it. Simple One Liner , You can use the below code to get the result that you are expecting. If the current element is not the same as the one in the prior index, create a new subarray. Then, push the current element into the most recently created subarray. You have to check all the array elements one by one with group of an array. Follow this code if you want to check the current element is the same as the previous element: You could take an optional chaining operator ?. and check if the last array exist with a value. The fastest way would to slice the array as you did in the second snippet. To include the latest item I would prefer to slice the latest chunk after the loop. Since you don't need to check the latest chunk in the loop it would be a bit faster. As one liner: You can use reduce and Array.prototype.at to get the result.