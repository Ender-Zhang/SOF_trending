I am trying to solve LeetCode problem 707. Design Linked List : Design your implementation of the linked list. You can choose to use a singly or doubly linked list. A node in a singly linked list should have two attributes: val and next . val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed . Implement the MyLinkedList class: MyLinkedList() Initializes the MyLinkedList object. int get(int index) Get the value of the index th node in the linked list. If the index is invalid, return -1. void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val) Append a node of value val as the last element of the linked list. void addAtIndex(int index, int val) Add a node of value val before the index th node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted . void deleteAtIndex(int index) Delete the index th node in the linked list, if the index is valid. Example 1: Input Output Explanation Wondering what's wrong with my LinkedList here. Can't get it past the input: with my output as: and the expected output as: This is my implementation: You have chosen to implement a doubly linked list, with two dummy (sentinal) nodes, head and tail . This is fine, but there are several issues in your code: In get , addAtIndex and deleteAtIndex , you start with curr equal to head , which means that if the given index is 0, curr will still be that head , while the node at index 0 really is the successor of your head . head doesn't count as node, as it is a dummy node. So you should start with curr = head.next instead of curr = head . As a consequence, in deleteAtIndex , you don't need the last part of the if condition ( curr.prev != null ), as this is now guaranteed. In the same three functions you have a loop condition that says tail != null , but this condition is always true. tail never is assigned anything else after its initialisation in the constructor (and it shouldn't). The loop condition should instead test curr != null . In addAtHead you have wired the nodes incorrectly. The assignment head.next = newHead; should happen after newHead.next = head.next; , because as you have it now, you make newHead.next to become equal to newHead , introducing a cycle in your list. In addAtTail the order of assignments is also in the wrong order. You make newTail.prev equal to newTail , introducing a cycle. In addAtIndex there are two wrong assignments. The first two would attempt to exclude curr from the list, but it should become the neighbor of the new node. Therefore you should do newNode.next = curr; instead of newNode.next = curr.next; . curr.next.prev = newNode; is also wrong, as this link should not be updated. It could even lead to an exception, because curr could be equal to the tail node, which has a null for its next field. Instead you should do curr.prev = newNode; Not a problem, but in get you have declared an unused variable i . You can drop it. Here is your code with the above corrections applied to it (see comments in code): As a next step, you could try to remove some code repetition, as you have essentially the same loop in three of these methods.