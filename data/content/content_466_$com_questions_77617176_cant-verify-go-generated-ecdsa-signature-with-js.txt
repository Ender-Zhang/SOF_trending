I've got a small issue, (My assumption is that there is one small thing holding me back but I have no clue what), as mentioned in the title. I will start by giving an overview about what I'm doing and will provide everything I have afterwards. Project overview I'm hashing files with SHA-256 in a mobile app and sign the hash in the backend with an ECDSA P-256 key. This is then persisted. If the user needs to he can verify the integretify of the file, by basically hashing the file again and looking up the hash and getting the hash, some metadata and the signature back. To validate the data has been submitted my app and not a third party (the hashs are persisted in a blockchain but that doesn't really matter for this issue), the app will attempt to verify the signature with the public key. This works fine. Now I would like to add this option to my website as well, however here is the issue. My signatures are not valid if I use the jsrsasign or the webcrypto api. Data Sample signature: 3045022100f28c29042a6d766810e21f2c0a1839f93140989299cae1d37b49a454373659c802203d0967be0696686414fe2efed3a71bc1639d066ee127cfb7c0ad369521459d00 Public Key: Hash: bb5dbfcb5206282627254ab23397cda842b082696466f2563503f79a5dccf942 Scripts JS Code App Verification Code (Flutter Dart) Key generation script (Go) Link to signature wrapper script: Link My Attemps I've tested with two new key pairs (and your lib) to sign some sample data to see if the something with the keys is wrong, it's not I've tested signing data with your lib and my private key and validating it with my public key to see if my private key is broken, it's not I've attempted the whole thing with the web crypto api, it didn't work I've attempted to load the ECDSA public key and use new KJUR.crypto.ECDSA({"curve":"secp256r1"}).verifyHex(hash, signature,pubKeyHex) with the data mentioned above, it didn't work (tested only in the browser console) I've used a Firefox and Safari to see if there is any difference, it didn't change anything I've tried passing my hash as string via sig.updateString(hashData) , it didn't work And some other smaller change stuff Compare hash, r & s + signature on web and app site, everything matches as it should. I've traced the whole thing from front to backend and there are no data changes My last attempt was the 4th attempt, since, from my understanding at least, if you are using the regular way (which I'm doing in the script above) your data get's hashed, which, in my case, is counter productive as I've already gotten a hash so if it's hashed twice it ,of course, won't match. However for reasons I don't get I still get false as return value. One final thought, could the issue be that the go ecdsa libary truncates the message down to 32 bytes if the P-256 signature is used? And maybe in JS it doesn't? The verification in the JavaScript code is incompatible with the Dart code for two reasons: Firstly, the JavaScript code uses KJUR.crypto.Signature() , which hashes the data implicitly . Since the data is already hashed, this results in double hashing. On the Dart side, no implicit hashing occurs (since no digest is specified in ECDSASigner() ). To avoid implicit hashing on the JavaScript side and to be compatible with the Dart code, KJUR.crypto.ECDSA() can be used instead of KJUR.crypto.Signature() . Secondly, updateHex() in the JavaScript code performs a hex decoding of the hex encoded hash, while in the Dart code the hex encoded hash is UTF-8 encoded. To be compatible with the Dart code, the hex encoded hash must also be UTF-8 encoded in the JavaScript code. The following JavaScript code fixes both issues: Now, verification is successful. Note regarding the UTF-8 encoding of the hex encoded hash: This produces 64 bytes, so that ECDSA with P-256 only considers the first 32 bytes of the data, i.e. the last 32 bytes are ignored (for more details see FIPS 186-5 , section 6.4, last paragraph). Actually this is either a bug or a bad design in the signing code. More correct would be a hex decoding, which would provide 32 bytes so that the entire data would be taken into account.