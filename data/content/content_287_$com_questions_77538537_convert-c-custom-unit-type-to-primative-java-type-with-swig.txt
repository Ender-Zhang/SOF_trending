I have C++ code that I am attempting to provide Java bindings using SWIG. I am hoping to try replace all references of meters_t to just be a double or Java.lang.Double . I've attempted the following in my SWIG interface .i file: However I am currently getting a typecast error Does anyone have any advice to correct this? I am quickly losing hope that the idea of converting meters_t into a simple double will be possible :/ UPDATE: I have also added the following Which enables the Java bindings to be built, however when I attempt to use the Java bindings (on a different struct that takes meters_t as a constructor arg, it immediately throws an error UPDATE 2.0 I now have meters_t SWIG wrapped. My new problem is a class with a boost default argument, and I'm getting the elusive Syntax error in input(3). error You have started on the right track with typemaps . These are crucial for converting types between C++ and Java. But the errors suggest that SWIG is having trouble automatically converting between meters_t and jdouble . You might need to provide custom typemaps to handle this conversion explicitly. You need to provide a way for SWIG to understand how to convert meters_t to jdouble and vice versa. Try and implement %typemap(in) and %typemap(out) for meters_t . These typemaps will define how to convert a meters_t object to a Java double when passing from C++ to Java, and vice versa. SWIG has limited support for parsing complex default arguments ]. One solution is to simplify the default argument in the SWIG interface file, or provide an overloaded version of the constructor without the default argument for SWIG to wrap. In your SWIG interface file , implement the typemaps: You  need to fill in the conversion logic based on how meters_t can be converted to and from a double . Regarding " Code to convert from jdouble to meters_t ", when converting from Java to C++, you will receive a Java double (represented as jdouble in C++ JNI code). You need to convert this to a meters_t object. Assuming meters_t can be constructed or assigned from a double , the typemap might look like this: In this typemap: $1 is the placeholder for the C++ argument (in this case, meters_t ). $input represents the input from Java (a jdouble ). The expression $input * boost::units::si::meter constructs a meters_t object from the Java double, assuming that meters_t can be initialized in this way. For " Code to convert from meters_t to jdouble ": When converting from C++ to Java, you need to extract a double value from your meters_t object: In this typemap: $1 is the placeholder for the C++ meters_t object. $result is the JNI representation of the Java type you are mapping to ( jdouble in this case). $1.value() is a hypothetical method or way to extract the double value from a meters_t object. You will need to replace this with the actual method or approach for extracting the numeric value from your meters_t type. Make sure that meters_t can be constructed from a double and has a method to extract its value as a double . If not, you will need to adapt the code to suit the actual interface of meters_t . These typemaps assume that boost::units::si::meter is the appropriate unit for conversion. Adjust if necessary based on your specific implementation of meters_t . Unfortunately this has not corrected my current outstanding issue. I have actually already attempted what you suggested with ignoring the constructor and providing another. C:\my_project\src\inc\foo.h(line of the foo ctor): Syntax error in input(3) . Given the error is in the foo.h , I feel like SWIG is unable to parse the default argument for whatever reason, where ignoring the code will not help; I imagine SWIG reading foo.h is independent of any directives in the SWIG Interface file? The error Syntax error in input(3) does indeed suggest that SWIG is having trouble parsing the C++ code in your header file, specifically the constructor with the default argument in foo.h . That can happen when the syntax or constructs used in the C++ code are too complex or unfamiliar to SWIG. If possible, simplify the constructor in the C++ header file. That means removing or altering the default argument in a way that SWIG can understand. For example, you could split the constructor into two: one without arguments and another taking a meters_t argument, handling the default case in the implementation rather than in the declaration. Create an overloaded version of the constructor specifically for SWIG. That version would not have the complex default argument. Use SWIG's %ignore directive to ignore the problematic constructor and expose only the simplified version. In your SWIG interface file: You can also use %inline to provide an alternative, SWIG-friendly version of the problematic code directly in the interface file. That allows you to keep the original C++ code as is but provide a simplified version for SWIG to process. The key is to create an interface that SWIG can parse without losing the functionality you need in the Java bindings. Yeah, modifying the ctor to provide a Foo() and Foo(meters_t meters) , where moving the initialisation of Foo::meters (meters = meters_t{ 0.0 * boost::units::si::meters }) to Foo.cpp corrects the issue. I would really much prefer to SWIG wrap the code in question without having to alter the source code. I feel like I am missing a boost header, but I have added the includes used in the .h file into my SWIG interface %module MyModule { //some boost headers } . In short, SWIG does not know what boost::units::si::meter is when it reads Foo.h !? I agree: you would prefer not to modify the original C++ source code to accommodate SWIG. The issue (where SWIG does not recognize boost::units::si::meter ) is likely due to SWIG's limited understanding of complex C++ constructs, especially from libraries like Boost . Including Boost headers in the SWIG interface file is a good start. However (again), SWIG might not fully understand or parse complex Boost constructs. Make sure you include the necessary Boost headers in your SWIG interface file, similar to how they are included in your C++ header files (though this might not always be feasible with complex templated types like those in Boost). As mentioned before, use %ignore to exclude the problematic constructor from SWIG's processing. Then, either use %extend to define a SWIG-friendly version of the constructor or %rename to expose a different, simplified constructor to Java. As a last resort, if SWIG struggles with the Boost types, consider creating a wrapper class in C++ that presents a simpler interface to SWIG. That wrapper would internally handle the Boost types and complexities, exposing only SWIG-friendly types and methods. Create a FooWrapper class that simplifies the interface for SWIG. Inside FooWrapper , manage the complex Boost interactions, exposing simpler methods for SWIG. Then in the SWIG interface file: The goal remains to find a balance between preserving the original C++ source code and providing SWIG with a form it can understand. In that context, creating a simplified interface or wrapper for SWIG can often be a practical solution, especially when dealing with complex libraries like Boost.