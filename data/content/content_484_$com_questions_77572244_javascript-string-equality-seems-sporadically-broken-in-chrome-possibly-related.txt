The bounty expires in 18 hours . Answers to this question are eligible for a +100 reputation bounty. Evan wants to draw more attention to this question. I have a function in my application that is (for a very small percentage of users, but for a few people every day) raising an error that seems impossible. It looks like, from the error the function raises, 'center' !== 'center' . Every occurrence of this error happens on Chrome, and the first occurrence was on October 16, 2023. Users run into this error once or twice, then it seems to resolve itself. Here's a simplified version of the function. There's a lot of code stripped out, but the relevant control flow is almost exactly the same. Here is the exact text of one of the errors I've seen: Error: Illegal gradient start ("center", center, 99,101,110,116,101,114,END) of type string. Webworker: false. Valid gradient starts are: (center,left-top,left,left-bottom,top,bottom,right-top,right,right-bottom, 99,101,110,116,101,114,END,108,101,102,116,45,116,111,112,END,108,101,102,116,END,108,101,102,116,45,98,111,116,116,111,109,END,116,111,112,END,98,111,116,116,111,109,END,114,105,103,104,116,45,116,111,112,END,114,105,103,104,116,END,114,105,103,104,116,45,98,111,116,116,111,109,END) So the constant start is a string, with value "center" , and all of the characters of the string are the same characters as the characters in the string "center" , in the same order. Yet start === 'center' can't have been true, because we didn't enter the first if statement and return. A few more details that may be relevant: The argument gradient is created in a web worker before being used in this function. gradient.start is converted to a JavaScript string from a Brython string type. And this error does occur for other values of start . Here's what I've tried so far: I added the detailed logging that I included above. I tried storing all strings in the function in constants, and using those constants to create the VALID_STARTS array, just in case some browser extension was modifying the strings, but that doesn't seem to be the case. I added more logging, not included above, to throw an error if we somehow entered the start === 'center' case and continued without returning, but that error has never triggered. I also tried to create a minimal example of a possible Web Worker bug (where the string 'abc' posted from a Web Worker may not equal 'abc' ). I ran it a few million times on my computer, but it never produced an error. The date of the first error doesn't coincide with a new Chrome release or any relevant deploys on my end. I briefly skimmed the open bugs in Chrome, but it didn't seem like I was going to have great luck there. I'd really appreciate hearing new perspectives on how to tackle this bug, and insights from any JS gurus out there. Could this string not be a string, despite typeof start being 'string' ? Could I be accidentally modifying the string prototype and breaking equality somehow? I'm not sure where to look next. Here's a link to the unedited source code for this function, if it would be helpful to look at: https://pastebin.com/0hdqLjqH Thanks so much for any ideas you might have! New information based on suggestions in the comments: I logged the following values right before the if (start == 'center') if statement. Their results are in comments next to the value. So there's progress! It's not clear to me why calling .toString() is making a difference, or how normalizing the string makes a difference when we already compared each character code. But we actually have something to go on now. The code doesn't even look correct.
Variable can never be the same object === as a constant.
However
Variable can equal == a constant.