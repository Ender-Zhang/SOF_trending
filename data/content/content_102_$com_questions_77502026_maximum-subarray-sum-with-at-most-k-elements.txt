Maximum subarray sum with at most K elements : Given an array of integers and a positive integer k, find the maximum sum of a subarray of size less than or equal to k. A subarray is a contiguous part of the array.
For example, if the array is [5, -3, 5, 5, -3, 5] and k is 3 , then the maximum subarray sum with at most k elements is 10 , which is obtained by the subarray [5, 5] My initial thought was to use the Kadane's algorithm with a sliding window of K. Below is the code: but this approach won't work for the test case - The basic issue in your code is it is always taking some of 3 elements after 3rd iteration. Iterations : 1 : sum_so_far = 5 maxi = 5 2 : sum_so_far = 5+(-3) maxi = 5 3 : sum_so_far = 5+(-3)+5 maxi = 7 4 : sum_so_far = (-3)+5+5 maxi = 7 5 : sum_so_far = 5+5+(-3) maxi = 7 6 : sum_so_far = 5+(-3)+5 maxi = 7 It is difficult to achieve expected result in single loop. Suggestion : you should always try to debug your code, first manually and still facing issue you can take help of GDB online for further debugging. This is what I wrote as a solution to above statement. Use two indices. On each iteration: First, advance the rear index when: The sum between the two indices is <= 0 The distance between the two indices (inclusive) is k The forward index is at the end of the array The value of the element at the rear index is <= 0 Then, advance the forward index when: We didn't advance the rear index We advanced the rear index past the forward index Keep track of the current & best sum between indices. Updates are O(1) since we just need to adjust for the element being included or excluded from the range between our indices. Stop when the rear index reaches the end of the array. If you want the matching indices as well, store these every time you find a new best sum. Ruby code (read as pseudocode if Ruby is unfamiliar) Sample Results Here is a similar solution which is a bit more explicit: When you drop the first element the new range may start with a negative number. This is never good. You might be tempted to drop all negatives as well: But this is not enough because the new range may still have a prefix sum less than zero, which would require restarting the range at that point. Apologies if I've misinterpreted your question, but as I understand it, you want to find the largest value that can be summed in a range (as small as 1 or as large as 'k') in your array. I've wrote a quick code that does just that, let me know if it falls short in anyway. There is an O(n) solution at https://cs.stackexchange.com/a/151327/10147 We can have O(n log n) with divide and conquer. Consider left and right halves of the array: the solution is either in (1) the left half exclusively, (2) the right half exclusively, or (3) a suffix of the left combined with a prefix of the right. To solve (3) in O(n), iterate from the middle to the left, recording for each index the higher of the highest seen or the total sum. Then iterate to the right and add a similar record for prefix length l with the recorded value for index k - l (or the longest possible if k-l is out of bounds) in the first iteration. For the example, [5, -3, 5, 5, -3, 5] k = 3 , we have: