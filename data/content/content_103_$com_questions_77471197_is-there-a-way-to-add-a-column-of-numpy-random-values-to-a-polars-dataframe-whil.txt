Let's say I have a dataframe that has a column named mean that I want to use as an input to a random number generator. Coming from R, this is relatively easy to do in a pipeline: Created on 2023-11-12 with reprex v2.0.2 In python, I can create an intermediate dataframe and use it as input to np.random.normal() , then bind that to the dataframe, but this feels clunky. Is there a way to add the random_output col as a part of the pipeline/chain? There are four approaches (that I can think of), 2 of which were mentioned in comments, one that I use, and the last I know it exists but don't personally use it. First (get_column(col) or ['col']) reference Use df.get_column as a parameter of np.random.normal which you can do in a chain if you use pipe so for example Second (map_batches) Use map_batches as an expression Third (numba) This approach is the faster than the previous two if you're going to do many randomizations but takes more setup (hence the caveat about many randomizations) numba lets you create ufuncs which are compiled functions which you can use directly inside an expression. You can create this function which just uses the default standard deviation then you can do More reading: guvectorize another numba example limitation Fourth (rust extension) Unfortunately for this answer (and I suppose myself in general) I haven't dabbled in rust programming but there's an extension interface whereby you can create functions in rust and deploy them as expressions. Here is documentation on doing that Performance Using a 1M row df I get... First method: 71.1 ms ± 8.06 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) Second method: 70.7 ms ± 7.88 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) Third method: 45.7 ms ± 2.86 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) One thing to note is that it's not faster unless you want a different mean for each row, for instance... df.with_columns(z=rando(pl.repeat(5,pl.count()))) : 43.8 ms ± 2.12 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) df.with_columns(z=pl.Series(np.random.normal(5,1,df.shape[0]))) : 39.6 ms ± 3.64 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)