I have been reading this other post , since I am dealing with a similar situation. However, I have a problem. In my version of df_1 , I have timestamps which are outside of the values of the time ranges presented in df_2 . Let's say I have an extra row I need to know how can I modify the solution to the previous post so that I get a null value for the fifth row, since I am getting now an error I would use janitor 's conditional_join that enables a left join easily and much more efficiently than using apply : Or, if your intervals are non-overlapping and you expect a single match, using merge_asof and a mask: Output: you can modify the lambda function to include error handling. Specifically, you can catch the KeyError that is raised when a timestamp does not match any interval in df_2. In such cases, you can return None or np.nan to indicate that there is no corresponding event. In this modified code, df_2.index.contains(x) checks whether the timestamp x is within any of the intervals in df_2. If it is, the corresponding event is returned. If not, np.nan is returned, indicating a null value. This approach should handle rows in df_1 with timestamps outside the ranges in df_2 without raising an error Refer to the answer from Mughees Syed : or: or: