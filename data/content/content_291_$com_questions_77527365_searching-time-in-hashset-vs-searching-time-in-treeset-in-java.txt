I have read that searching time in TreeSet is of the order of log(N) and in HashSet is of the order of 1 (Constant). Now, to test this in a program I have written a Java program. After running this program several times, these are the results I got: Output 1: Time taken by TreeSet MINUS Time Taken by HashSet = 105.6000 nanoseconds Output 2: Time taken by TreeSet MINUS Time Taken by HashSet = 99.1000 nanoseconds Output 3: Time taken by TreeSet MINUS Time Taken by HashSet = 36.8000 nanoseconds Output 4: Time taken by TreeSet MINUS Time Taken by HashSet = 50.6000 nanoseconds Output 5: Time taken by TreeSet MINUS Time Taken by HashSet = -30.4000 nanoseconds I was expecting the time difference to be somewhat a larger value but, in some cases, the difference of time is as low as 36 nanoseconds and even negative in some cases. Is this what I should be expecting? or have I missed something while writing the program? Yes. You've missed a lot. So much, in fact, it's almost impossible for you to this right. Good news though, there's a library for that. Specifically, JMH . The JVM is not a simple thing. It runs code slowly and does all sorts of seemingly pointless bookkeeping so that it knows which 0.1% of the code spends 95% of the CPU resources (those aren't exaggerated numbers; that's what most apps end up doing. An academic case that just tests the speed of some algorithm obviously isn't like that, but the JVM is optimized for real life apps, not test cases). Once it figures out what that is, it uses all that seemingly pointless bookkeeping to craft a highly optimized bit of machine code that e.g. is written to optimize branching (CPUs tend to be faster at 'do not jump' then 'do jump', which is what any loop structure is translated to. The JVM knows which 'path' is, so far, taken more often and optimizes accordingly. Compile-time only optimizers can't do that without hints). That's one of about 900 reasons why you can't just rely on calculating the delta between 2 nanoTime() calls and extract meaningful conclusions about timing. JMH fixes some of this. Not all, but most. Follow the tutorial linked above, hang your benchmark in a JMH harness, and then check your results.