output: only 3 values are taken eventually so I would like it to run the mappers as little as possible, if it were truely lazy evaluation then i would expect the first mapper to run once, producing 2 values, then the second mapper to run twice, producing 4 values the 1 parameter to mergeMap should do something of this sort but does not really i got a bit close using concatMap but still not perfect i think it is something subtle about the interoperation of promises and rxjs There are a few reasons why the mergeMap in your example may not be lazy. Promise.resolve is already eagerly evaluated, so the duplicateValue function will always return a resolved promise before the mergeMap even runs. The concatAll operator itself is not lazy. It immediately subscribes to the inner observables and begins emitting values. So even if the mergeMap were lazy, the concatAll will still eagerly consume all the values. The take operator also eagerly subscribes to the source observable and begins emitting values. So even if the mergeMap and concatAll were lazy, the take will prevent them from being lazily evaluated. In order to have lazy evaluation, you would need to use operators like defer or Observable.create to defer the execution until the subscription happens. Additionally, you would have to avoid Promise.resolve and instead use defer or Observable.fromPromise to create a lazy promise.