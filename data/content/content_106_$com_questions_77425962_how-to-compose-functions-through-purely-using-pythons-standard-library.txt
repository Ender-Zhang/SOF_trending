Python's standard library is vast, and my intuition tells that there must be a way in it to accomplish this, but I just can't figure it out. This is purely for curiosity and learning purposes: I have two simple functions: and I want to compose them into a new function double_and_increment . I could of course simply do that as such: but I could also do it in a more convoluted but perhaps more "ergonomically scalable" way: Both of the above work fine: Now, the question is, is there tooling in the standard library that would allow achieving the composition without any user-defined lambdas, regular functions, or classes. The first intuition is to replace the lambda acc, f: f(acc) definition in the functools.reduce call with operator.call , but that unfortunately takes the arguments in the reverse order: I have a hunch that using functools.reduce is still the way to accomplish the composition, but for the life of me I can't figure out a way to get rid of the user-defined lambda. Few out-of-the-box methods that got me close: Have looked through all the existing questions, but they are completely different and rely on using user-defined functions and/or lambdas. Well, since you're saying I want to "abuse" the language and only use existing definitions from the standard library starting with Python 3.12, the test suite happens to contain the gadget you want : (I found this by way of a strategic ag compose in my local CPython checkout.) While it is cool that @AKX found the function test.test_zipfile._path._functools.compose in the CPython code tree that perfectly implements the OP's desired functionality of function composition, it does not actually belong to the standard library as required by the rules of the question, for reasons that: It belongs to a helper module in a test suite of the CPython implementation of the Python language. A test suite is not part of the standard library of the language; it is just code that validates a particular implementation of the language and its standard library. A test suite, let alone any helper functions within the test suite, may be removed at any time without any normal due process of advanced deprecation warnings. Other implementations of Python does not need to include any of CPython's test suite in order to conform to Python's specifications. So, without the helper function in the test suite of CPython 3.12 that is not part of the standard library, I believe the OP is indeed correct in the assessment that there is no out-of-the-box tooling in Python's standard library that can implement function composition. BUT, that doesn't mean we can't achieve it by modifying existing tooling, since the OP's rules are simply to use "tooling in the standard library that would allow achieving the composition without any user-defined lambdas, regular functions, or classes" . Since the OP almost got it already with: and: The real question here is then how we can modify an existing function in the standard library such that it becomes: To do that, let's take a look at the bytecode of the above function, as well as relevant attributes of the code object that defines the parameters: No surprise there. A simple function body that loads the second argument ( obj ) and the first argument ( value ) onto the stack, then make a call with the callable and the argument in the stack, and finally returns the value at the top of the stack to the caller. Now, let's find a similarly simple function in the standard library that takes an argument or two and make a call with it/them, so it can more easily be modified into our desired function. As it turns out, operator.abs is one such function, which takes one argument and makes a wrapper call to the built-in _abs function: We'd want to disassemble it for comparison, and yet unfortunately, if we try accessing operator.abs.__code__ , you would get an error: This is because CPython's implementation of the operator module includes an _operator module, which overrides all of the operator.py 's pure-Python functions with ones implemented in C, wit a try block in operator.py : Functions implemented in C do not have __code__ objects and therefore cannot be modified. What we need is the pure Python version of operator.call , before it's overridden by _operator.call . But how do we avoid the override? Well, we can import _operator module ourselves first and and delete the call attribute from it so that the modified module is cached in sys.modules such that when operator.py imports _operator , it is our modified version that it gets, without call in it: Great! Now we can finally get to look at the bytecode and relevant attributes of the code object of operator.abs : As can be seen, all we need to modify to turn operator.abs into our desired function object is to replace the LOAD_GLOBAL instruction into PUSH_NULL (to indicate a regular function call for CALL ) and LOAD_FAST 1 (to load the second argument, the callable), as well as co_varnames , co_argcount and co_nlocals to add a second parameter obj . To obtain a modified code object from the existing code object of operator.abs we can call its replace method: This correctly outputs: So it then becomes trivial to implement the composite function that the OP wants, by plugging in the modified operator.call into the OP's close attempt: This outputs: Demo: here As mentioned in the other answer of mine I don't agree that the test suite discovered by @AKX should be considered as part of the standard library per the OP's rules. As it turns out, while researching for an existing function to modify for my other answer, I found that there is this helper function _int_to_enum in the signal module that perfectly implements operator.call for a callable with a single argument, but with parameters reversed, exactly how the OP wants it, and is available since Python 3.5: So we can simply repurpose/abuse it: This outputs: Demo: here