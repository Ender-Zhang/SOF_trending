I'm still learning QueryDSL prior to converting some legacy code from QueryDSL 3.x to 5.x. I have this code: Clearly there are a bunch of things wrong with this. But for now, I need to understand how to use limit() , and offset() while also returning the entire record count so we can implement the paging as well. Can I use fetchCount() on the original query and get the entire size? Or is there something else I have to do? I don't know if what I'm about to post is the best way, but it's working for me. This is a sample project, and it appears to work. In short, I prepared the basic query in buildBookQuery() . I then clone the query and change the select as you readily see. Then in runBookQuery() I added an order-by and the limit and offset calls before doing the fetch. I have no idea if this is the optimal way. I'm fairly sure this turns into two hits to the database. SELECT count(*) is usually, but not always fast. If there's another way to do this, I hope someone posts a better method. UPDATED NOTE: The QueryDSL page says this: fetchCount requires a count query to be computed. Inquerydsl-sql, this is done by wrapping the query in a subquery, like so: SELECT COUNT(*) FROM (<original query>). Unfortunately, JPQL - the query language of JPA - does not allow queries to project from subqueries. As a result there isn't a universal way to express count queries in JPQL. Historically QueryDSL attempts at producing a modified query to compute the number of results instead. However, this approach only works for simple queries. Specifically queries with multiple group by clauses and queries with a having clause turn out to be problematic. This is because COUNT(DISTINCT a, b, c), while valid SQL in most dialects, is not valid JPQL. Furthermore, a having clause may refer select elements or aggregate functions and therefore cannot be emulated by moving the predicate to the where clause instead. In order to support fetchCount for queries with multiple group by elements or a having clause, we generate the count in memory instead. This means that the method simply falls back to returning the size of fetch(). For large result sets this may come at a severe performance penalty. For very specific domain models where fetchCount() has to be used in conjunction with complex queries containing multiple group by elements and/or a having clause, we recommend using the Blaze-Persistence integration for QueryDSL. Among other advanced query features, Blaze-Persistence makes it possible to select from subqueries in JPQL. As a result the BlazeJPAQuery provided with the integration, implements fetchCount properly and always executes a proper count query. I think that means my answer is wrong. I'll post a fresh answer if I get this to work with Blaze Persistence. Final Edit I did more testing and updated my initial answer to fix a few things. First, I was doing my join sub optimally, and when my table size grew, my queries grew even when they shouldn't have (returning 4 records, taking 10 seconds). The copy you see is the right way. The wrong way: a better way: with no on() call. The second argument is listed as alias , but my select clause can do book.title the way I wrote it originally. In spite of the huge paragraph from QueryDSL javadocs, this is working in a timely fashion. If I query against a small member (few books) or a large count (11000) but small page size, the call is very fast, as it should be, and the count returned is accurate. Unless someone tells me I'm doing this wrong, this is my final answer.