I need to pass a password to a call. If I do When the code got scanned by Fortify, it was reported the code has an vulnerability of "Heap inspection" due to the assignment of password to a String. Fortify does not complain the original code: even though env.getProperty() does return a String. What Fortify recommend is: But how can you use char[] as password when the function expect a String? Yea ... base64 encoding a password is no protection at all.  Any hacker with half a brain knows how to recognize and decode base64.  So your "weird base64 stuff" is not helping. But the flipside is that your vulnerability scanner is pointing out a problem that is relatively hard to exploit, AND is probably not going to be solvable anyway. At some point in your application (its dependencies, or somewhere) the password is going to be converted into a Java String ... because some API requires a String .  At that point you have a "heap inspection" vulnerability whether or not the scanner tells you about it.  For instance, if the data source uses JDBC, that password needs to be passed as a parameter to a DriverManager.connect call.  There are 3 overloads for connect ... but they all entail passing the password as a clear-text string.  Fixing that is impractical. (Clearly, the so-called fix suggested by Fortify is obviously not going to work.  And it fails to notice that your call to setPassword(env.getProperty("spring.datasource.password")) is just a "bad" as what you are currently doing.  This is "performative security" ...) The most practical solution is to tell the scanner that this is a "false positive".  Then take steps to prevent hackers from being able to attach a debugger, inspect RAM, core dumps, swap disks, etc and trawl through the heap looking for String objects that might represent passwords. There is also a "nasty" solution that entails smashing through type abstraction on the String object and overwriting its backing array.  But that approach is fragile. The representation of String has changed a number of times over the life of Java, and each change would potentially break your String overwriting code. In some circumstances the backing array of a String is shared with other String objects and smashing the backing array will damage those objects. There is the problem of finding all of the cases where the password String might have been copied or inserted into other String objects. Unless you are dealing with classified information , this is (IMO) over the top.  And if you are dealing with classified information, secure your platform before you go to these lengths.  (And don't rely on dumb security scanner software to do your security audits!) Evidently you need to call an existing method that takes a String argument which is a password. Therefore you must give it a String argument that is a password. Whether or not you assign the String to an intermediate variable, it is still a String that is a password. There is no security difference between having a variable or not. There is one String either way. Of course, if your scanner is too stupid to notice a String that is not assigned to a variable, maybe that will work.
' inline it?