I read here and here that Python methods can be aliased using = . However, when I try it on the __init__ method, it doesn't seem to work. The b = MyClass.new_name() causes this error: Why does this not work? And how should I alias __init__ correctly? __init__ is not a constructor. __new__ is. __init__ is an instance method that performs initialization on an instance after it is constructed by the static method __new__ . The reason why both __new__ and __init__ are called when you call the class with MyClass() is because it is what the __call__ method of the type, or metaclass, of MyClass , does. So if you want to properly alias the constructor of a class you can alias the __call__ method of its metaclass: Alternatively, you can make the alias a classmethod descriptor that binds type.__call__ to the current class: Both approaches would output: The __init__ method was aliased. But __init__ is not a constructor to begin with. You could probably do: If you want things to "just work". But this is rather weird IMO. Just define a classmethod .