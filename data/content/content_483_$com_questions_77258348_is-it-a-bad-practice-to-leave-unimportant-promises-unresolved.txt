This question already has answers here : Can I fire and forget a promise in nodejs (ES7)? (4 answers) Are there any (negative) side effects when I don't use the "then" function of a Promise? (1 answer) Are JavaScript forever-pending promises bad? (2 answers) Does never resolved promise cause memory leak? (1 answer) Closed 2 months ago . I'm trying to wrap my head around a practice that I've now noticed across different codebases where functions are leaving supplementary async function calls unresolved. I assume that this is done to potentially save on performance, as waiting for the promise to be resolved might add additional overhead to gain no real benefit (if the promise is not important to the result of the function) other than guarantee that everything has finished. A common example I've seen of this is with caching: Am I correct to assume that in the above example, there exists a scenario where someFunction has finished before cacheResult is resolved? If so then I assume that cacheResult will resolve "at some arbitrary time later"? What if I have someFunction wrapped in a try/catch block: But cacheResult promise resolves into a rejection some time later. Will this result in an unhandled promise rejection and terminate the process even though I had it surrounded in try/catch ? Assuming that proper error handling is in place for cacheResult and it is a complex function taking a considerable amount of time, is it a valid practice to then leave it to resolve on its own and continue with processing to not lose performance? Am I correct to assume that in the above example, there exists a scenario where someFunction has finished before cacheResult is resolved? In fact, it's pretty much guaranteed. cacheResult will immediately execute but it won't resolve yet (unless you don't do any async work and immediately return). To illustrate: If so then I assume that cacheResult will resolve "at some arbitrary time later"? Yes. In fact, if cacheResult was implemented like this, it would not even resolve at all: But cacheResult promise resolves into a rejection some time later. Will this result in an unhandled promise rejection and terminate the process even though I had it surrounded in try/catch? Yes. This will not catch exceptions in the cacheResult call and will result in an unhandled promise rejection: The error message points you at this answer, in fact. Assuming that proper error handling is in place for cacheResult and it is a complex function taking a considerable amount of time, is it a valid practice to then leave it to resolve on its own and continue with processing to not lose performance? Yes, that's totally fine: You might want to consider adding a mechanism that makes sure that a slow cacheResult() call doesn't overwrite a newer cacheResult() that just happened to finish sooner (eg save a timestamp or a revision number). Yes, it's bad practice to have ever-pending promises, because they occupy resources. But there are no (obvious) unresolved promises in your example. Just because you don't await a promise, this doesn't mean it won't resolve (assuming that cacheResult eventually finishes). And yes, it's totally fine, to don't await promises if you don't care for their result right now. But yes, your code will throw an unhandled promise rejection, even if you wrap your await someFunction() into a try {...} catch {...} block, because you lose the context for the promise returned by cacheResult . Ie the async code in someFunction() will long be finished (and the promise returned by it will long be resolved (or maybe rejected)) before the promise returned by cacheResult will either resolve or reject. So, if you don't want to await cacheResult or you don't care whether it's successful or not, either make it to not throw under any circumstances by doing or add a rejectionhandler, when you call it Both of these variants will let cacheResult finishing somewhat later but still catch any error it throws. But be aware of one thing: For instance nodejs may not wait for pending promises and terminate nonetheless, so your cacheResult function may be terminated at any time, if there is nothing else going on keeping your process alive ...