I have been translating the Ray Tracing in One Weekend guide into Java as a personal project and to get better at java. Obviously, Java is slower than C++, so I'm trying to implement multi-threading to improve performance. However, with multi-threading, the code is running slower than it does with a single thread. I've tried to ensure that each thread is independent of each other (tested via visualvm) so that they aren't waiting. Thread Timeline I'm not completely sure what to make of the results of sampling the memory. Memory Heap Histogram Per Thread Allocation VisualVM Overview The code below is the multi-threaded render function. Essentially, I render the whole image N times with samples/N samples where N is the number of threads. Then, the images are averaged into one final image. Lastly each pixel is printed (this occurs outside of the thread, in main). I have a slightly older version of the code (without the multi-threading) on github if you need extra context. Java Raytracer Lastly, at an image width of 400 pixels and samples per pixel at 128 in single threaded mode, the total render time is about 12 seconds. With multi-threading (run at 4 threads) it takes about 21 seconds. Run on a 16GB M1 Macbook Air. Why is the multi-threaded code performing worse than the single thread code? How can I fix it? Multiprocessing works however and cut the render time in half when creating four processes. Lastly, at an image width of 400 pixels and samples per pixel at 128 in single threaded mode, the total render time is about 12 seconds. With multi-threading (run at 4 threads) it takes about 21 seconds. Run on a 16GB M1 Macbook Air. Something is really wrong that the multi-threaded case takes almost twice as long.  I just tried a whittled down test: With numThreads set to 1, the program took 130 seconds and with 4 it took 36 seconds.  This is my macbook pro running Chrome, etc.. So Java threads work in general (duh).  Here's what to look for in your application to see what's screwing up the parallelism: First off, does running the same code with threads = 1 actually run faster?  Try separating the number of jobs from the number of threads.  Does 1 thread running each of the 4 jobs serially really run faster?  Make sure you are comparing apples to apples. Although you seem to be doing a copy of the working data, maybe the threads are sharing a complex data structure so what you are seeing is cache coherence conflicts that is killing your performance.  I'd be surprised that it would take twice as long but I guess it's possible. As others have mentioned, be careful of world.createCopy(...) and other calls that aren't being run in parallel but may take longer than you think.  Same question with the final image generation.  Maybe adding some println(...) messages with timestamps around some of these calls to see if one is taking longer than you expect. Is there some way that the getRay(...) or other shared methods synchronize on common data?  Similar to the cache coherence question. Hope something in here helps.