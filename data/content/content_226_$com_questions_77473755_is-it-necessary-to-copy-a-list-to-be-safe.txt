The implementation (and documentation) of Stream.toList is like this: I'm wondering why the list returned by Arrays.asList needs to be copied to a new ArrayList . Would it not be sufficient to just return the following? I would like to know, if I write a method that returns a list that it creates like this, would there be any issues if I didn't bother to make a defensive copy of it? It has a purpose I'm wondering why the list returned by Arrays.asList needs to be copied to a new ArrayList. Would it not be sufficient to just return the following? Which .toArray() are we talking about? If we're talking about the one from j.u.Collection , you're right: The javadoc of that toArray() method guarantees that it is a newly allocated array, hence, no need to make a defensive copy. However, that's not the toArray() involved here: We're talking about j.u.s.Stream 's .toArray() . Its javadoc is a lot shorter: Unlike j.u.Collection toArray() , this javadoc makes no notes either way about the nature of that array. Hence, evidently, the default impl in the Stream javadoc does not presume the array is necessarily 'safe' ('safe' in the sense: Will not later be modified). I think you know, but just to be crystal clear: Arrays.asList is almost always a mistake. It's a worst-of-both-worlds list: It creates a light wrapper around the array you pass to it. So, set() works (because foo[x] = value; is possible and indeed, is how that is implemented), but .add() doesn't (because you can't change the size of an array). The list is not immutable (i.e. if passing it to code outside of your direct control you need to extensively document, or, make a defensive copy), but also not a fully featured list. Use List.of instead, which makes fully immutable lists - lists you can pass around to whomever you like without worrying about losing control of integrity. EDIT: And to explain why its Collections.unmodifiableList(new ArrayList<... ) instead of List.copyOf - The immutable lists that those static methods on List make throw NPEs when null is in there, but streams can have null , so you can't use that. This edit brought to you by a comment from @Rob Spoor :) This is not as big an issue as you think, though Note that the code you found is merely the default implementation - any particular implementation of stream is free to come up with a better way to do this. Just about every implementation you are bound to run into overrides the definition. For example, if you call an arraylist's stream() , you end up with this implementation instead, which is from streamops and is the same code path used by all the collections in the core libs. Hence, the actual code you end up using, is this: 'trusted array' here refers to the notion that the array passed to it is guaranteed not going to change out from under you. There is no way the compiler can enforce that guarantee, but arraylist's (and indeed, all non-broken collections, given that the javadoc of j.u.Collection demands it!) toArray() makes new arrays so it's safe to do that, and this is far more efficient (avoids a bunch of needless copies). Unmodifiable view backed by a modifiable collection From the Javadoc (emphasis mine): An unmodifiable view collection is a collection that is unmodifiable and that is also a view onto a backing collection. Its mutator methods throw UnsupportedOperationException, as described above, while reading and querying methods are delegated to the backing collection. The effect is to provide read-only access to the backing collection. This is useful for a component to provide users with read access to an internal collection, while preventing them from modifying such collections unexpectedly. Examples of unmodifiable view collections are those returned by the Collections.unmodifiableCollection, Collections.unmodifiableList, and related methods. Note that changes to the backing collection might still be possible, and if they occur, they are visible through the unmodifiable view . Thus, an unmodifiable view collection is not necessarily immutable. However, if the backing collection of an unmodifiable view is effectively immutable, or if the only reference to the backing collection is through an unmodifiable view, the view can be considered effectively immutable. As the Collections.unmodifiableList returns a unmodifiable view of the backing list, it is still possible to modify the backing list which will impact the unmodifiable list. Now, the list is in turn backed by the array provided in the Arrays.asList method. So, everything depends on this.toArray() . As it is inside a default method of the Stream interface, it is dependent on the actual implementation of the stream whether toArray() returns a something modifiable or not. That's why it needs to be copied. When talking about safe , we usually refer to whether the object is immutable unmodifiableList -> unmodifiable here only guarantee caller can not change the state of wrapped list, and change of source will still be reflected in the wrapped list. new ArrayList<> -> defensive copy means modifying source will not change the state of the copy and vice versa. unmodifiable + defensive copy -> immutable , you can assume the list always hold the same list of object reference. Concrete example to demonstrate the difference You should see below when you run the code. Reference Immutable vs Unmodifiable collection The reason for creating a new ArrayList in the implementation you provided is to ensure that the returned list is truly unmodifiable. The Arrays.asList method returns a fixed-size list backed by the original array. An alternative and more modern approach to obtaining an unmodifiable list is to use the Collectors.toUnmodifiableList() method from the Stream API. For example: Arrays.stream(this.toArray()).collect(Collectors.toUnmodifiableList()); This approach directly produces an unmodifiable list without the need for creating an intermediate ArrayList. I hope this suggestion proves helpful. I don't have an answer but I find the implementation of Arrays.asList() funny, since it also creates a list inside: I wonder what happened, maybe its one of those: "this only applies to certain VMs so cant be guaranteed" If you are not writing a library I wouldn't mind to much to be honest. T would also need to be immutable for true safety btw. EDIT: intresting stuff, apparently this ArrayList is a different ArrayList , nothing strange