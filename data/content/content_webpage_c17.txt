Consider the following If I try and compile the line that has been commented out, the error message is clear: reference to non-static member function must be called . The two workarounds I've found are used to set member_func2 and member_func3 , and are fairly intuitive. For member_func2 , we create a very thin lambda wrapper that captures the target object by reference, and in the body calls the object's member function we are interested in. For member_func3 , we utilize std::mem_fn to create a std::function<void(Foo&)> . This also appears to also be a wrapping function that takes the target object by reference as the first parameter, and then invokes its member function we are interested within its operator()() function. The type signature on member_func3 is very reminiscent of c-style parameter conventions. Now that the setup is complete, here is my main point: It would be really nice to be able to just write rather than needing to call out to larger constructs (lambdas and std::mem_fn ). What is the reason for this design? Is there an underlying reason in the standard that prevents this? Is it computationally difficult or even impossible to do this with only the information provided to the compiler in the line above? Any illumination on this subject is appreciated. Why can't a nonstatic member function be referred to without calling it? The above assumption is wrong. You can refer to(point to) a member function without calling it as shown below: Also note that technically a reference(as opposed to) to member is not possible.