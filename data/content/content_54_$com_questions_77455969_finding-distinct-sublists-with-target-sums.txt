I am currently working on a task that involves identifying distinct sublists from a given list such that each sublist adds up to one of the specified target numbers. Below is the Python code I've written to address this problem. The primary approach in this recursive function involves iteratively removing elements from the list and assigning them to a sublist corresponding to one of the target numbers or discarding them. The function terminates either when a solution is found and outputs the result or when it's unable to complete due to an empty list or overshooting in one of the sublists. However, I've encountered a persistent flaw in the code that I can't seem to resolve. The problem lies in the fact that the same list element gets appended to different sublists, and the algorithm fails to exclude list elements as expected. I've thoroughly reviewed the code, but I can't pinpoint why this issue persists. The following snippet shows an example instance: However, I expect the output: Note that the output is (value, index) pairs. Here we have two ways of getting the target numbers of 3 & 5: They're identical except for which given 3 is used to achieve the 3 target vs the 5 target. I would greatly appreciate any assistance that could help me identify and rectify the problem in my implementation. Thank you in advance for your help :) In this section: When your function is called with the example you provided: Even on the second iteration there's already a problem. On the first iteration, next_total_partial is set to total_partial , and then next_total_partial is updated on the next line. But this modifies both total_partial and next_total_partial , as they have the same value. So, on the second iteration, you think you reset next_total_partial with: But in fact, nothing changes - it still has the same object as a value and you now add the same value ( (3, 3) in this case) to both next_total_partial and total_partial . Perhaps you wanted next_total_partial = total_partial.copy() ? The same applies to next_partial_sum = partial_sum.copy() of course. It would be possible to fix your logic to get it to work, but it's not a very efficient approach and it has a few other problems: the main issue is what I pointed out: you pass around the same objects where you need copies you have a recursive function, but you also use it for initialisation - this would be better with a secondary outer function, or an inner function you're brute-forcing a solution when there's more efficient ways to achieve this An example of a working solution that fixes some of the issues, but has the same approach you chose: Even closer, and perhaps preferable to you: