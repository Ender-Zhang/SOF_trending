I am trying to make an app for electric vehicle drivers and i'm using a text file to store the data the way it works is i have the name of the electric vehicle and the the line under the name contains the miles it can get per 1%, i've got it so it can find the specific car but i can't find the range of the vehicle using that number. this is what i have but every time it finds the car it won't find the range after it. I'd suggest to read the file into a dictionary, then use that dictionary to find the car, e.g.: Prints: Once you call cars.read(), it reads the entire content of the file into car, so there's nothing left for cars.readline() to read. You'll want to read the file line by line. If the line has the name of the car, then read the next line for the miles. i.e. Source: My article https://ioflood.com/blog/python-read-file-line-by-line/ You can do the following: f is a consumable iterator. You iterate over it until you find your car, then the next item in that iterator is what you're looking for. Also note that you don't store the whole file in the memory in case you're dealing with a huge file. (In that case why wouldn't you use a proper database?) Here are some other approach you can try: Sample Input : Output: The immediate problem is that read() reads all the remaining data from the file into memory; you can then no longer read() or readline() from the same file handle, because it is already at the end of the file. You could traverse the entire list in memory and print the entry after the one which matched, using readlines() which similarly reads the entire file, but conveniently returns the lines as a list of strings. However, to avoid reading a potentially large amount of text into memory just to immediately discard it, perhaps only read one line at a time, and stop as soon as you find a match. This takes a bit of thinking to wrap your head around if you haven't seen code like this before. Basically, we are examining a line at a time, and keeping a couple of state variables to keep track of what we have done on previous lines. car_line keeps track of whether this is an odd line (the start of a new record, i.e. information about a new car) or an even line (meaning it belongs with the previous car line) found keeps track of whether we have found the car we are looking for. So, read a line. If it's not the car we are looking for, just update the car_line to remind us of what we just did. Then read another line. This is not a car_line so we take the else , and it was not found , so we do nothing with it. Read the next line again. Repeat until the car line matches. At this point, set found to remind us to print and exit after the next line. And then, finally, when you read the next line after that, you see that it is not a car line, and that the information we need is now found, so print and exit. The assignment car_line = 1 - car_line implements a toggle. If car_line is 1, the new value will be 0; and if it is 0, the new value will be 1. (This generalizes nicely to toggling between two arbitrary states.) A much better solution is to rewrite your data into a properly machine-readable format, like CSV or JSON, or perhaps a SQLite database, and then take it from there. The logic above can be used for that, too, with fairly minor modifications. Here is a CSV converter. Searching the resulting CSV file is then somewhat more straightforward and convenient. If you need to manipulate the data more than just a few times, probably save it in a database instead, and index the field you want to search on.