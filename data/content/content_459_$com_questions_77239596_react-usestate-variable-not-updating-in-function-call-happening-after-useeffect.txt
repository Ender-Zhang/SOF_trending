I'm making a React component that takes some time to finish loading. Meanwhile, if the user attempts to invoke a function on it (e.g., testIfDoneLoading()), I aim to save that function call.
Once the component is ready, I can execute the saved function call as requested. I am using useState to initialize a loading state variable with a default value of true. When the component is mounted, I update the loading state by invoking setLoading(false), setting it to false. I've implemented a useEffect hook that monitors changes in the loading state. When loading transitions to false, I trigger the queued function if it is defined. The issue is that when I call the queued function, despite being called from the useEffect where I verify loading has been set to false, loading is still set to true and queues up the function again instead of continuing. However, if I directly call the function (not via queuedFunction ), it works fine, with loading being set to false. Here's the stackblitz and code below. Notice how the console says it is still loading despite the template showing loading is finished. If you uncomment the direct function call ( testIfDoneLoading() ) and comment out the queued function ( queuedFunction.current() ), it works as intended. It is because when you are calling testIfDoneLoading() in your useEffect it is a closure . When you define the function testIfDoneLoading it remembers the variables that are in the parent function, it bundled with its lexical scope (loading in this case). Then when you call the function testIfDoneLoading() you capture the variable value of loading at this time. Example: So when you do loading is 'captured' as true by the closure testIfDoneLoading() . And when you do loading is 'captured' as false by the closure testIfDoneLoading() .