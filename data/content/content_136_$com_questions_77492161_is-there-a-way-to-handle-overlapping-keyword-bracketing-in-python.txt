Suppose I have a list of keywords and an input string labelled section, I want my code to find those keywords within section and put them inside [] square brackets. However, my keywords sometimes overlap with each other. keywords = ["alpha", "alpha beta", "alpha beta charlie", "alpha beta charlie delta"] To fix that I sorted them by length so that the longer keywords would be prioritized.
However, when I run my code, sometimes I would get double or nested brackets (I assume it is because it still detects those as valid keywords) I tried this: Do not mind the line splits, it is for another part of to handle multiple lines. I wanted:
[alpha] [alpha beta] [alpha beta charlie] [alpha beta charlie delta] but instead I got:
[alpha] [alpha] beta] [alpha] beta] charlie] [alpha] beta] charlie] delta] You can join the sorted keywords into an alternation pattern instead of substituting the string with different keywords 4 times, each time potentially substituting the replacement string from the previous iteration: This outpouts: This solution here works for your specific example, though it assumes that the section string you are working with is ordered from shortest slice to longest slice . My solution gets removes the biggest slice of the string, in this case 'alpha beta charlie delta' , then the second biggest, and onwards. It appends these sections to a list, which I then sort by length, and lastly, add square braces to each element in the list as I add them to a string. Code below: If you're looking for maximum flexibility you could consider making a state machine. Warning, this is really going for the overkill award. I won't go into detail on state machines here, there's plenty of resources out there that would cover it much better than I would (here's one that gives an example in Python ). Still, here's a rough rundown of what's going on in the example below: The most important thing to take a look at is self.transitions . This defines a dict of states. Each state has a collection of triggers that declares the next state and any actions that should be taken when transitioning to that state. When KeywordFinder.find_keywords() is called, it iterates through each word in the input then uses that word to create a trigger. If that trigger exists in the current state then it moves to the next state and calls the action associated with that transition. In short, this will allow you to handle more complex inputs. For example, compare the output of the following input using the state machine approach with the regex approach. You'll find that getting the right results with regex is pretty tricky. section = "alpha alpha beta alpha beta charlie alpha beta charlie delta beta charlie alpha alpha beta charlie alpha delta beta alpha charlie alpha beta charlie" Anyways, here's a working example: