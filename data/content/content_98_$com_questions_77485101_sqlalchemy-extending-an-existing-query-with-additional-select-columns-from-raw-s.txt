I'm quite new to SQLAlchemy and Python, and have to fix some bugs in a legacy environment so please bear with me.. Environment : Python 2.7.18 Bottle: 0.12.7 SQLAlchemy: honestly don't know but something from 2014 (might be 0.9.8?) MySQL: 5.7 Scenario : I have this SQL Statement below that pivots a linked table and adds rows dynamically as additional columns in the original table - I constructed it in SQL Workbench and it returns the results I want: All specified columns from table t1 plus the additional columns with values from table t2 appear in the result Problem : I have an already existing SQLAlchemy session, that expands a query to be used for pagination. Currently this query returns all my specified columns from table t1, that are joined with tables t2 and custom_fields to get all necessary columns. The missing part is the SQLAlchemy representation for the SELECT GROUP_CONCAT part of the above statement, the rest is all taken care of - since I have control and know how the Frontend presenation of this table looks and now also the raw SQL version in SQL Workbench, I tried to work backwards to get the SQLAlchemy / Python part right by consulting https://docs.sqlalchemy.org/en/14/orm/queryguide.html#orm-queryguide-selecting-text and https://docs.sqlalchemy.org/en/14/core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns , but now I am stuck at how to get this TextClause object converted into a TextualSelect without typing the columns statically in the .column() function cause I don't know what the column names, that the users provide for these custom_fields, will be. Goal : concat a dynamically created raw SQL statement to my existing SQLAlchemy query to select these dynamically created fields from a linked table so that I have the same result as when I execute this raw SQL statement in a SQL editor Attempts : A : This results in this error: AttributeError: 'Select' object has no attribute 'from_statement' B : Changing the line (x) above that constructs the query for the additional rows to select_custom_fields_columns_stmt = session.select().from_statement(text(... --> results in: AttributeError: 'Session' object has no attribute 'select' C : adding a .subquery("from_custom_fields") statement at (y) --> results in: AttributeError: 'AnnotatedTextClause' object has no attribute 'alias' D : other attempts for (x) substituting select() with session.query() or session.query(Tags) also didn't result in additional columns What else can I try? Would it be preferable/easier to write the whole raw SQL part in SQLAlchemy and if so, how could I do that? -- Update & Examples : As suggested I have provided a SQLfiddle that has all the relevant information, but doesn't return any results (I am too inexperienced on how to use it): http://sqlfiddle.com/#!9/90a0c87/2 Also provided a DB-fiddle example with the exact same information to re-create a minimal example and here also the results are returned: https://dbfiddle.uk/NtPVWU8D ORM definitions for the 3 relevant tables, basically the Tags table and the CustomFields table use a CustomFieldTagLink association table to establish the link between these two. I expect the SQL query when executed to return a list of Tags items that are later processed and converted to dicts, however in this instance it is about adding the "pivot table" with the added custom_fields columns to the tags table to the already existing SQLAlchemy query object, as the execution of that statement happens later (filter, sort, paginate etc needs first to be done)