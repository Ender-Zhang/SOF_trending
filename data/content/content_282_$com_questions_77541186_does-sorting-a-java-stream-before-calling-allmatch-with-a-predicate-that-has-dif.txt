I have implemented a Java stream pipeline where some elements are sorted and checked if all of them fulfill a predicate. The pipeline looks like this: The validation by the predicate differentiates in costs. Some of the elements just need to check an attribute, for some of them I have to fetch potentially many elements from a database and evaluate them, too. As I need to know that all of them are true, knowing that at least one is false, is equivalent. If I correctly understand the JavaDoc of the allMatch() operation, it should short curcuit as soon as one element is false. So, in order to potentially improve the execution speed, I order the elements so that all of the very easy validations are executed first and only if they all succeed, I execute the more costly validations. That is at least what I think happens. However, my IDE tells me, that sorting before calling allMatch() is redundant, because it does not depend on the sort order. I wrote some tests which seem to indicate that the sort order is in fact regarded when traversing the pipeline, but maybe my test case is just to small or it just happened to be called correctly. So my question is: Does allMatch() consider the sort order imposed beforehand? Or does it ignore it? From your description The validation by the predicate differentiates in costs. Some of the elements just need to check an attribute, for some of them I have to fetch potentially many elements from a database and evaluate them, too. I created a simple test case. The class Waiter has a single int property that defines the sort order and also how long it takes to evaluate the predicate: The class Sorter creates a few Waiter s and outputs the time for allMatch() on either the unsorted or the sorted list of waiters: And the result is as expected: if the Waiter that whos predicate evaluates to false is the first (i.e. the data is sorted) the allMatch() is evaluated faster: Note that if I change the last Waiter to also wait 500ms the unsorted variant is always faster (because sorting takes time and doesn't change the output for the case where all predicates match) Please remember that this is a very simplistic test and may be skewed by various factors: this is not a proper microbenchmark. There is no warmup and only a two runs of both tests. The numbers might look different after a proper warmup. sorting itself takes time. In this simple case the time to sort the data is small, but your data may differ sorting pays off only if allMatch() can short-circuit (i.e. at least one predicate fails) on the other hand, for the case where all predicates return true you have a performance penalty due to the sorting Conclusion: sorting the stream offers benefits if some predicates fail and sorting has the effects that the predicates that fail are moved to the beginning of the sorted stream. for the case where all predicates match there is a penalty for the sorting You need to find out which of those two cases better describes your problem. Does allMatch() consider the sort order imposed beforehand? Or does it ignore it? If you are asking ... does allMatch() have to wait until the stream contents are sorted, the answer is going to be yes, for a sensible implementation of sorted() 1 . If you are asking if allMatch() could benefit from the stream being sorted, then the answer is yes, because of possible short-circuiting in allMatch when it encounters an element for which the predicate returns false .  (The javadocs don't say that short-circuiting will happpen 2 , but that would be a legitimate implementation approach.) But could also go the other way.  It depends ... The question of whether it is more efficient to sort first will depend on the relative costs of equals vs validate , AND on the probability that elements will fail to validate.  There will be a point where you spend more time sorting than you will gain on average by reducing the allMatch() cost. Unfortunately ... the mathematics of this will be complicated 3 , and will require accurate cost functions and probability distributions to provide an valid answer. My advice would be make sure you are not doing premature optimization.  And when you do optimize, make sure that your trial datasets are representative.  My intuition says that the optimal algorithm is likely to be very data dependent, and that can makes optimization problematic. But here's a thought.  Rather than sorting in ascending order of cost of validation, how about sorting in descending order of probability of validation failure? 1 - In theory, sorted could deliver the first (smallest) element in the stream in O(N).  However, optimizing it to do that would most likely be an anti-optimization overall. 2 - The javadoc says "[may not evaluate the predicate on all elements if not necessary for determining the result." .  It does not say will not or shall not . 3 - ... and way beyond my ability. So my question is: Does allMatch() consider the sort order imposed beforehand? Or does it ignore it? I found no guarantees in the JavaDoc that allMatch will respect the encounter order. It might be implemented to respect the encounter order anyway. Relevant sections of the documentation are (emphasis mine): Streams may or may not have a defined encounter order. [...] Some intermediate operations, such as sorted() , may impose an encounter order on an otherwise unordered stream. Further, some terminal operations may ignore encounter order , such as forEach() . If a stream is ordered, most operations are constrained to operate on the elements in their encounter order. So allMatch could very well be implemented so that it does not process elements in the sorted order, similar to findAny and forEach . I can't think of a good reason why someone would implement it that way, but nevertheless, the documentation does not guarantee. As always with performance, the best thing to do is to race your horses . Actually write benchmarks on some real data to see which one is faster. The performance depends on many more factors than just "does allMatch respect the order". If you have a large number of items , for example, it might not be worth the effort to sort all of them, regardless of whether allMatch respects the order.