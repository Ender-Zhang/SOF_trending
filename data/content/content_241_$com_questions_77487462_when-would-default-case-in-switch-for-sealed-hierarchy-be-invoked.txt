Given a sealed hierarchy as below Since Rectangle & Square are records, it inherently makes the whole hierarchy non-extensible i.e. no more subclasses are allowed any more. Starting JDK 21, pattern matching for switch enforces switch to be exhaustive either by covering all possible case or by providing a default case to cover the remaining. Thus, for below switch under what circumstances default case would be executed as all possible combinations are covered and why is it even permitted? P.S. : The sealed hierarchy definitely can evolve, but when that happens compiler will automatically flag the switch to upgrade itself too. The answers so far are mostly correct, but there is more to the story. The simple answer given so far -- which is that there might be runtime values that match no case, regardless of compile-time type checking for exhaustiveness -- are correct.  A default class is allowed because it is possible that it is selected (and if you don't provide one, the compiler gives you a synthetic one that throws MatchException.) There are two primary reasons why a switch that is exhaustive at compile time might not be truly exhaustive at runtime: separate compilation, and remainder. Separate compilation has been treated adequately in the other answers; novel enum constants and novel subtypes of sealed types can show up at runtime, because it is possible to recompile the hierarchy without recompiling switches over it.  This is normally handed silently for you by the compiler (there's no point in making you declare a default clause that just throws "can't get here"), but you can handle it yourself if you want. The second reason is remainder , which reflects the fact that the reasonable meaning of "exhaustive enough" and actual exhaustiveness do not fully coincide, and if we demanded that switches be truly exhaustive, it would be very unfun to program in. A simple example is this: Should this switch be exhuastive on Box<Box<String>> ?  As it turns out, there is one possible value at runtime it does not match: Box(null) .  (Recall that nested patterns match the outer pattern, and then use the bindings of the outer pattern as match candidates for the inner pattern -- and a record pattern cannot match null, because it wants to invoke the component accessors.) We could demand that to be exhaustive, there be a separate error handling case for Box(null) , but no one would like that, and with less trivial examples, the error handling would overwhelm the useful cases.  So Java makes the pragmatic choice of defining switch exhaustiveness in "human" terms -- the code that seems exhaustive for the reasonable classes -- and allowing for the "silly" cases to be handled by the synthetic default.  (You are still free to handle any silly cases explicitly if you want.)  This switch is considered exhaustive, but with non-empty remainder. This whole concept is explained in greater detail in Patterns: Exhaustiveness, Unconditionality, and Remainder . The sealed hierarchy definitely can evolve, but when that happens compiler will automatically flag the switch to upgrade itself too. This is not true. You seem to be assuming that both the switch statement and the records/sealed interfaces will always be compiled together. Of course, this will likely be true in most practical situations, but it is not always true. You can compile the sealed interfaces and records without recompiling the switch statement. For example, suppose the types are all in separate .java files named with their names, so Shape.java, Rectangle.java, Square.java, while the switch statement is in the main method in Main.java. First, I compile all the Java source files I have, and produces .class files for every .java file. Then, suppose I change Shape.java to: and added a Triangle.java file. After that, I will compile just the records and the sealed interface, without compiling  Main.java. This is possible, because they don't depend on Main.java. Finally, I run java Main . This will run the Main.class file, which doesn't know about the new Triangle class, because it was compiled before I added Triangle . This is where the default branch will be executed, or if you don't have a default branch, this is where a MatchException will be thrown. (Note that the MatchException part only applies to switch expressions and the enhanced switch statements , like the one in your question. Non-enhanced switch statements simply don't do anything if no cases match.) See also Execution of a switch Statement and Run-Time Evaluation of switch Expressions in the Java Language Specification.